<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Word Catch - Standalone</title>
    <link rel="stylesheet" href="styles.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
</head>
<body>
    <div id="app">
        <div id="menu" class="screen active">
            <h1 class="title">WORD CATCH</h1>
            <p class="subtitle">данная игра — метод расслабления. играйте в удовольствие.</p>
            <div class="options">
                <label>
                    Сложность
                    <select id="difficulty">
                        <option value="easy">Лёгкая</option>
                        <option value="medium" selected>Средняя</option>
                        <option value="hard">Сложная</option>
                    </select>
                </label>
                <label>
                    Режим окна
                    <select id="screenMode">
                        <option value="window">В окне</option>
                        <option value="fullscreen">Полный экран</option>
                    </select>
                </label>
            </div>
            <button id="startBtn" class="btn">Начать</button>
            <div class="authors">Авторы: команда np hero</div>
        </div>

        <div id="game" class="screen">
            <div class="hud">
                <div>Очки: <span id="score">0</span></div>
                <div>Жизни: <span id="lives">3</span></div>
                <div>Время: <span id="timer">60</span>с</div>
            </div>
            <div class="question">Вопрос: <span id="questionText"></span></div>
            <canvas id="gameCanvas" width="900" height="540"></canvas>
            <div class="dropbar">Соберите ответ перетаскиванием слов ↓</div>
        </div>

        <div id="end" class="screen">
            <h2>Время!</h2>
            <p class="result">Ваш результат: <span id="finalScore">0</span></p>
            <p class="prompt">Совет: <span id="randomPrompt"></span></p>
            <button id="backToMenu" class="btn">В меню</button>
        </div>
    </div>

    <script>
        // Встроенные данные из CSV (вместо загрузки с сервера)
        const REFLECTIONS_DATA = [
            {
                reflection_id: "R0001",
                prompt_text: "О чём ты сейчас беспокоишься? Что можно отпустить?",
                answer_text: "Почувствовал(а), что короткий перерыв помогает.",
                insight_tags: ["фокус"],
                required_words: ["короткий", "перерыв", "помогает"]
            },
            {
                reflection_id: "R0002", 
                prompt_text: "Что получилось хорошо за последние 2–3 часа?",
                answer_text: "Замечаю, разговор с коллегой отвлёк.",
                insight_tags: ["цели"],
                required_words: ["разговор", "коллегой", "отвлёк"]
            },
            {
                reflection_id: "R0003",
                prompt_text: "Какая одна маленькая вещь поможет следующему шагу?",
                answer_text: "Почувствовал(а), что дыхание выравнивает фокус — попробую завтра снова.",
                insight_tags: ["граница-раб-лич"],
                required_words: ["дыхание", "выравнивает", "фокус"]
            },
            {
                reflection_id: "R0004",
                prompt_text: "За что ты благодарен(на) в работе сегодня?",
                answer_text: "Сегодня понял(а), что стоит закрыть лишние вкладки и стало легче.",
                insight_tags: ["перерыв"],
                required_words: ["закрыть", "лишние", "вкладки"]
            },
            {
                reflection_id: "R0005",
                prompt_text: "Что бы ты сделал(а) иначе в следующий раз?",
                answer_text: "Кажется, лучше записать следующий шаг и это сэкономит время.",
                insight_tags: ["план"],
                required_words: ["записать", "следующий", "шаг"]
            }
        ];

        const PROMPTS_DATA = [
            { prompt_id: "P1", text: "О чём ты сейчас беспокоишься? Что можно отпустить?", category: "рефлексия" },
            { prompt_id: "P2", text: "Что получилось хорошо за последние 2–3 часа?", category: "рефлексия" },
            { prompt_id: "P3", text: "Какая одна маленькая вещь поможет следующему шагу?", category: "рефлексия" },
            { prompt_id: "P4", text: "За что ты благодарен(на) в работе сегодня?", category: "рефлексия" },
            { prompt_id: "P5", text: "Что бы ты сделал(а) иначе в следующий раз?", category: "рефлексия" }
        ];

        // Standalone игровая логика
        class StandaloneGame {
            constructor() {
                this.questions = [...REFLECTIONS_DATA];
                this.currentQuestionIndex = 0;
                this.score = 0;
                this.lives = 3;
                this.timeRemaining = 60;
                this.collectedWords = [];
                this.flyingWords = [];
                this.gameRunning = false;
                this.difficulty = 'medium';
                
                this.initializeElements();
                this.bindEvents();
            }

            initializeElements() {
                this.screens = {
                    menu: document.getElementById('menu'),
                    game: document.getElementById('game'),
                    end: document.getElementById('end')
                };

                this.elements = {
                    startBtn: document.getElementById('startBtn'),
                    difficulty: document.getElementById('difficulty'),
                    screenMode: document.getElementById('screenMode'),
                    score: document.getElementById('score'),
                    lives: document.getElementById('lives'),
                    timer: document.getElementById('timer'),
                    questionText: document.getElementById('questionText'),
                    canvas: document.getElementById('gameCanvas'),
                    finalScore: document.getElementById('finalScore'),
                    randomPrompt: document.getElementById('randomPrompt'),
                    backToMenu: document.getElementById('backToMenu')
                };

                this.ctx = this.elements.canvas.getContext('2d');
            }

            bindEvents() {
                this.elements.startBtn.addEventListener('click', () => this.startGame());
                this.elements.backToMenu.addEventListener('click', () => this.showScreen('menu'));
                
                // Canvas events
                this.elements.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.elements.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.elements.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
            }

            showScreen(screenName) {
                Object.values(this.screens).forEach(s => s.classList.remove('active'));
                this.screens[screenName].classList.add('active');
            }

            startGame() {
                this.difficulty = this.elements.difficulty.value;
                this.currentQuestionIndex = 0;
                this.score = 0;
                this.lives = 3;
                this.timeRemaining = 60;
                this.collectedWords = [];
                this.gameRunning = true;

                this.showScreen('game');
                this.loadCurrentQuestion();
                this.gameLoop();
            }

            loadCurrentQuestion() {
                if (this.currentQuestionIndex >= this.questions.length) {
                    this.endGame();
                    return;
                }

                const question = this.questions[this.currentQuestionIndex];
                this.elements.questionText.textContent = question.prompt_text;
                
                // Генерируем летающие слова
                this.generateFlyingWords(question);
            }

            generateFlyingWords(question) {
                this.flyingWords = [];
                const requiredWords = question.required_words;
                const distractionWords = ["сегодня", "завтра", "потом", "сейчас", "очень", "быстро", "медленно"];
                
                // Добавляем нужные слова
                requiredWords.forEach(word => {
                    this.flyingWords.push({
                        word: word,
                        x: Math.random() * 800,
                        y: Math.random() * 400,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        collected: false
                    });
                });

                // Добавляем отвлекающие слова
                for (let i = 0; i < 3; i++) {
                    const word = distractionWords[Math.floor(Math.random() * distractionWords.length)];
                    this.flyingWords.push({
                        word: word,
                        x: Math.random() * 800,
                        y: Math.random() * 400,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        collected: false
                    });
                }

                // Перемешиваем
                this.flyingWords.sort(() => Math.random() - 0.5);
            }

            handleMouseDown(e) {
                if (!this.gameRunning) return;
                
                const rect = this.elements.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                for (const word of this.flyingWords) {
                    if (!word.collected && this.isPointInWord(x, y, word)) {
                        this.draggedWord = word;
                        break;
                    }
                }
            }

            handleMouseMove(e) {
                if (!this.draggedWord) return;
                
                const rect = this.elements.canvas.getBoundingClientRect();
                this.draggedWord.x = e.clientX - rect.left;
                this.draggedWord.y = e.clientY - rect.top;
            }

            handleMouseUp(e) {
                if (!this.draggedWord) return;
                
                const rect = this.elements.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Проверяем, попал ли в зону сброса
                const dropZone = { x: 20, y: 460, w: 860, h: 60 };
                if (x >= dropZone.x && x <= dropZone.x + dropZone.w && 
                    y >= dropZone.y && y <= dropZone.y + dropZone.h) {
                    
                    this.draggedWord.collected = true;
                    this.collectedWords.push(this.draggedWord.word);
                    this.checkAnswer();
                }

                this.draggedWord = null;
            }

            isPointInWord(px, py, word) {
                const width = word.word.length * 9;
                const height = 16;
                return px >= word.x && px <= word.x + width && py >= word.y && py <= word.y + height;
            }

            checkAnswer() {
                const currentQuestion = this.questions[this.currentQuestionIndex];
                const requiredWords = new Set(currentQuestion.required_words);
                const collectedWords = new Set(this.collectedWords);

                // Проверяем, собраны ли все нужные слова
                const hasAllWords = [...requiredWords].every(word => collectedWords.has(word));
                
                if (hasAllWords) {
                    // Правильный ответ
                    const points = this.calculatePoints();
                    this.score += points;
                    this.currentQuestionIndex++;
                    
                    if (this.currentQuestionIndex >= this.questions.length) {
                        this.endGame();
                    } else {
                        this.collectedWords = [];
                        this.loadCurrentQuestion();
                        this.timeRemaining = 60; // Сброс времени для нового вопроса
                    }
                }
            }

            calculatePoints() {
                const basePoints = 100;
                const timeBonus = Math.floor(this.timeRemaining * 2);
                const difficultyMultiplier = {
                    'easy': 1,
                    'medium': 1.5,
                    'hard': 2
                }[this.difficulty] || 1;
                
                return Math.floor((basePoints + timeBonus) * difficultyMultiplier);
            }

            endGame() {
                this.gameRunning = false;
                this.elements.finalScore.textContent = this.score;
                
                // Случайный промпт
                const randomPrompt = PROMPTS_DATA[Math.floor(Math.random() * PROMPTS_DATA.length)];
                this.elements.randomPrompt.textContent = randomPrompt.text;
                
                this.showScreen('end');
                
                // Автоматически возвращаемся в меню через 5 секунд
                setTimeout(() => this.showScreen('menu'), 5000);
            }

            update(deltaTime) {
                if (!this.gameRunning) return;

                this.timeRemaining -= deltaTime;
                if (this.timeRemaining <= 0) {
                    this.lives--;
                    if (this.lives <= 0) {
                        this.endGame();
                        return;
                    }
                    this.timeRemaining = 60;
                    this.collectedWords = [];
                }

                // Обновляем позиции летающих слов
                for (const word of this.flyingWords) {
                    if (!word.collected) {
                        word.x += word.vx;
                        word.y += word.vy;

                        // Отскок от границ
                        if (word.x < 0 || word.x > 800) word.vx *= -1;
                        if (word.y < 0 || word.y > 400) word.vy *= -1;
                        
                        word.x = Math.max(0, Math.min(800, word.x));
                        word.y = Math.max(0, Math.min(400, word.y));
                    }
                }
            }

            draw() {
                // Очищаем canvas
                this.ctx.fillStyle = '#071012';
                this.ctx.fillRect(0, 0, 900, 540);

                // Рисуем зону сброса
                this.ctx.strokeStyle = '#00ffaa';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(20, 460, 860, 60);

                // Рисуем летающие слова
                this.ctx.fillStyle = '#7dfaa7';
                this.ctx.font = '16px "Share Tech Mono"';
                this.ctx.textBaseline = 'top';
                
                for (const word of this.flyingWords) {
                    if (!word.collected) {
                        this.ctx.fillText(word.word, Math.floor(word.x), Math.floor(word.y));
                    }
                }

                // Рисуем собранные слова
                this.ctx.fillStyle = '#d0ffd0';
                this.ctx.fillText(this.collectedWords.join(' '), 30, 470);

                // Обновляем HUD
                this.elements.score.textContent = this.score;
                this.elements.lives.textContent = this.lives;
                this.elements.timer.textContent = Math.max(0, Math.floor(this.timeRemaining));
            }

            gameLoop() {
                const now = performance.now();
                const deltaTime = (now - (this.lastTime || now)) / 1000;
                this.lastTime = now;

                this.update(deltaTime);
                this.draw();

                if (this.gameRunning) {
                    requestAnimationFrame(() => this.gameLoop());
                }
            }
        }

        // Запускаем игру
        const game = new StandaloneGame();
    </script>
</body>
</html>
